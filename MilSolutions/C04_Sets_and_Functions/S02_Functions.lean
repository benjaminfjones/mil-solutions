import MilSolutions.Common
import Mathlib.Data.Set.Lattice
import Mathlib.Data.Set.Function
import Mathlib.Analysis.SpecialFunctions.Log.Basic

section

variable {Œ± Œ≤ : Type*}
variable (f : Œ± ‚Üí Œ≤)
variable (s t : Set Œ±)
variable (u v : Set Œ≤)

open Function
open Set

example : f ‚Åª¬π' (u ‚à© v) = f ‚Åª¬π' u ‚à© f ‚Åª¬π' v := by
  ext
  -- simp only [preimage_inter, mem_inter_iff, mem_preimage]
  rfl

#check f '' s  -- : Set Œ≤

-- Note: The rintro decompositons don't actually need to rewrite `f x = y` using `rfl`
-- because of definitional equality
example : f '' (s ‚à™ t) = f '' s ‚à™ f '' t := by
  ext y; constructor
  ¬∑ -- y ‚àà f '' (s ‚à™ t) defined as
    -- ‚àÉ x, x ‚àà s ‚à™ t ‚àß f x = y
    rintro ‚ü®x, xs | xt, _ /- rfl -/‚ü©
    ¬∑ left
      use x, xs
    right
    use x, xt
  rintro (‚ü®x, xs, _ /- rfl -/‚ü© | ‚ü®x, xt, _ /- rfl -/‚ü©)
  ¬∑ use x, Or.inl xs
  use x, Or.inr xt

example : s ‚äÜ f ‚Åª¬π' (f '' s) := by
  intro x xs
  show f x ‚àà f '' s
  -- use x, xs  -- Done
  -- illustrates how `use` follows up with `rfl` when it can close the goal
  refine ‚ü® x, xs, ?_ ‚ü©
  rfl

-- AKA: `image_subset_iff`
--
-- `image f` and  `preimage f` are an instance of a Galois connection between Set Œ± and Set Œ≤,
-- each partially ordered by the subset relation.
example : f '' s ‚äÜ v ‚Üî s ‚äÜ f ‚Åª¬π' v := by
  constructor
  ¬∑ intro fsv
    -- fsv : { y | ‚àÉ x ‚àà s, f x = y } ‚Üí v
    intro x xs
    have h : f x ‚àà f '' s := by
      refine ‚ü® x, xs, ?_ ‚ü©
      rfl
    have h' : f x ‚àà v := fsv h
    assumption
  intro ssv  -- s ‚Üí f ‚Åª¬π' v
  -- goal: exhibit a fn from f '' s ‚Üí v
  intro z zfs
  rcases zfs with ‚ü®w, hw, rfl‚ü©
  exact ssv hw


example (h : Injective f) : f ‚Åª¬π' (f '' s) ‚äÜ s := by
  intro x xffs
  have hfx : f x ‚àà f '' s := xffs  -- restate the defintion
  rcases hfx with ‚ü®y, hy, fxfy‚ü©
  rw [‚Üê h fxfy]
  assumption

example : f '' (f ‚Åª¬π' u) ‚äÜ u := by
  rintro y ‚ü®z, hz, rfl‚ü©
  -- ‚ä¢ f z ‚àà u  def=  z ‚àà f ‚Åª¬π' u
  assumption


example (h : Surjective f) : u ‚äÜ f '' (f ‚Åª¬π' u) := by
  intro y yu
  rcases h y with ‚ü®x, hx‚ü©
  have hxu : f x ‚àà u := by rw [hx]; assumption
  refine ‚ü® x, hxu, ?_‚ü©
  assumption


example (h : s ‚äÜ t) : f '' s ‚äÜ f '' t := by
  intro y hy
  rcases hy with ‚ü® x, xs, fxy‚ü©
  have : x ‚àà t := h xs
  use x


example (h : u ‚äÜ v) : f ‚Åª¬π' u ‚äÜ f ‚Åª¬π' v :=
  -- { x | ‚àÉ y ‚àà u ‚àß f x = y } ‚Üí { x | ‚àÉ y ‚àà v ‚àß f x = y }
  fun _x xfu => h xfu

-- AKA: `preimage_union`
example : f ‚Åª¬π' (u ‚à™ v) = f ‚Åª¬π' u ‚à™ f ‚Åª¬π' v := by
  ext x
  constructor
  ¬∑ rintro (hu | hv)
    ¬∑ left; assumption
    right; assumption
  rintro (xfu | xfv)
  ¬∑ left; assumption
  right; assumption


example : f '' (s ‚à© t) ‚äÜ f '' s ‚à© f '' t := by
  rintro y ‚ü®x, ‚ü®xs, xt‚ü©, fxy‚ü©
  constructor
  rw [‚Üê fxy]
  use x
  use x


example (h : Injective f) : f '' s ‚à© f '' t ‚äÜ f '' (s ‚à© t) := by
  rintro y ‚ü®yfs, yft‚ü©
  rcases yfs with ‚ü®x, xs, fxy‚ü©  -- an `x` mapping to `y` in `f '' s`
  use x
  -- could use refine ‚ü®?_, fxy‚ü©, but we can emphasize the remaining goal with suffices
  suffices xst : x ‚àà s ‚à© t by exact ‚ü®xst, fxy‚ü©
  rcases yft with ‚ü®x', xt, fxy'‚ü©
  rw [‚Üê fxy] at fxy'
  have xx' : x' = x := h fxy'
  rw [xx'] at xt
  exact ‚ü®xs, xt‚ü©


example : f '' s \ f '' t ‚äÜ f '' (s \ t) := by
  intro a ha
  simp_all only [mem_diff, mem_image, not_exists, not_and]
  obtain ‚ü®‚ü®w, ‚ü®ws, fwa‚ü©‚ü©, aright‚ü© := ha
  subst fwa
  use w
  simp_all only [true_and, and_true]
  intro hwt
  have : ¬¨ f w = f w := aright w hwt
  contradiction


-- AKA: `preimage_diff`
example : f ‚Åª¬π' u \ f ‚Åª¬π' v ‚äÜ f ‚Åª¬π' (u \ v) := by
  simp_all only [preimage_diff, subset_refl]

-- aesop proves this in 24 lines
-- we have 12 lines
example : f '' s ‚à© v = f '' (s ‚à© f ‚Åª¬π' v) := by
  ext x
  simp_all only [mem_inter_iff, mem_image, mem_preimage]
  constructor
  ¬∑ rintro ‚ü®‚ü®x1, x1s, fx1x‚ü©, xv‚ü©
    use x1
    refine ‚ü®‚ü®x1s, ?_‚ü©, fx1x‚ü©
    rwa [fx1x]
  ¬∑ rintro ‚ü®x1, ‚ü®x1s, fx1v‚ü©, fx1x‚ü©
    rw [‚Üê fx1x] at *
    constructor
    ¬∑ use x1
    assumption


example : f '' (s ‚à© f ‚Åª¬π' u) ‚äÜ f '' s ‚à© u := by
  -- convert to preimage, which ends up not depending on `u` at all
  simp_all only [subset_inter_iff, image_subset_iff, inter_subset_right, and_true]
  have : s ‚à© f ‚Åª¬π' u ‚äÜ s := by apply inter_subset_left
  apply subset_trans this
  exact subset_preimage_image f s


example : s ‚à© f ‚Åª¬π' u ‚äÜ f ‚Åª¬π' (f '' s ‚à© u) := by
  simp only [preimage_inter, subset_inter_iff, inter_subset_right, and_true]
  -- same exact proof as above after the simp
  have : s ‚à© f ‚Åª¬π' u ‚äÜ s := by apply inter_subset_left
  apply subset_trans this
  exact subset_preimage_image f s


example : s ‚à™ f ‚Åª¬π' u ‚äÜ f ‚Åª¬π' (f '' s ‚à™ u) := by
  simp only [preimage_union, union_subset_iff, subset_union_right, and_true]
  apply subset_trans (subset_preimage_image f s)
  exact subset_union_left

variable {I : Type*} (A : I ‚Üí Set Œ±) (B : I ‚Üí Set Œ≤)

example : (f '' ‚ãÉ i, A i) = ‚ãÉ i, f '' A i := by
  ext y
  constructor
  ¬∑ rintro ‚ü®x, xs, fxy‚ü©
    rw [mem_iUnion] at *
    rcases xs with ‚ü®j, xAj‚ü©
    use j
    have him : f x ‚àà f '' (A j) := by exact mem_image_of_mem f xAj
    rwa [fxy] at him
  rw [mem_iUnion]
  rintro ‚ü®j, x, xAj, fxy‚ü©
  have hxUAi : x ‚àà ‚ãÉ i, A i := by rw [mem_iUnion]; use j
  rw [‚Üê fxy]
  exact mem_image_of_mem f hxUAi


example : (f '' ‚ãÇ i, A i) ‚äÜ ‚ãÇ i, f '' A i := by
  rintro y ‚ü®x, xAj, fxy‚ü©
  rw [mem_iInter] at *
  intro i
  rw [‚Üê fxy]
  exact mem_image_of_mem f (xAj i)


-- Note: original does not have a typo extra hypothesis: `(i : I)`, it is required
-- unless we resort to the axiom of choice for `I`.
example (i‚ÇÄ : I) (injf : Injective f) : (‚ãÇ i, f '' A i) ‚äÜ f '' ‚ãÇ i, A i := by
  rw [subset_def]
  intro x
  rw [mem_iInter]
  intro hx
  rcases hx i‚ÇÄ with ‚ü®z, _, fzx‚ü©
  refine ‚ü®z, ?_, fzx‚ü©

  show z ‚àà ‚ãÇ i, A i
  rw [mem_iInter]
  intro j
  rcases hx j with ‚ü®zj, zjAj, fzjx‚ü©
  have zzj : z = zj := injf (Eq.trans fzx fzjx.symm)
  rwa [‚Üê zzj] at zjAj


example : (f ‚Åª¬π' ‚ãÉ i, B i) = ‚ãÉ i, f ‚Åª¬π' B i := by
  ext x
  simp only [mem_preimage, mem_iUnion]


example : (f ‚Åª¬π' ‚ãÇ i, B i) = ‚ãÇ i, f ‚Åª¬π' B i := by
  ext x
  simp only [mem_preimage, mem_iInter]


example : InjOn f s ‚Üî ‚àÄ x‚ÇÅ ‚àà s, ‚àÄ x‚ÇÇ ‚àà s, f x‚ÇÅ = f x‚ÇÇ ‚Üí x‚ÇÅ = x‚ÇÇ :=
  Iff.refl _

end

section

open Set Real

example : InjOn log { x | x > 0 } := by
  intro x xpos y ypos
  intro e
  -- log x = log y
  calc
    x = exp (log x) := by rw [exp_log xpos]
    _ = exp (log y) := by rw [e]
    _ = y := by rw [exp_log ypos]


example : range exp = { y | y > 0 } := by
  ext y; constructor
  ¬∑ rintro ‚ü®x, rfl‚ü©
    apply exp_pos
  intro ypos
  use log y
  rw [exp_log ypos]

example : InjOn sqrt { x | x ‚â• 0 } := by
  intro x1 x1nn x2 x2nn h
  calc
    x1 = (‚àöx1)^2 := by apply (sq_sqrt x1nn).symm
    _  = (‚àöx2)^2 := by rw [h]
    _  = x2      := by apply sq_sqrt x2nn

-- same proof
example : InjOn (fun x ‚Ü¶ x ^ 2) { x : ‚Ñù | x ‚â• 0 } := by
  intro x1 x1nn x2 x2nn h
  have h' : x1^2 = x2^2 := by assumption  -- restate h
  calc
    x1 = ‚àö(x1^2) := by apply (sqrt_sq x1nn).symm
    _  = ‚àö(x2^2) := by rw [h']
    _  = x2      := by apply sqrt_sq x2nn

example : sqrt '' { x | x ‚â• 0 } = { y | y ‚â• 0 } := by
  ext z
  constructor
  ¬∑ rintro ‚ü®x, _, sqrt_xz‚ü©
    have sqrt_x_nn : 0 ‚â§ ‚àöx := by apply sqrt_nonneg
    rwa [sqrt_xz] at sqrt_x_nn
  intro znn
  use z^2
  constructor
  ¬∑ show 0 ‚â§ z^2
    apply sq_nonneg
  exact sqrt_sq znn

example : (range fun x ‚Ü¶ x ^ 2) = { y : ‚Ñù | y ‚â• 0 } := by
  ext z
  constructor
  ¬∑ rintro ‚ü®x, fxz‚ü©
    have h : x^2 = z := fxz  -- restate fxz
    rw [‚Üê h]
    show 0 ‚â§ x^2  -- restate goal; didn't think this would be neccesary
    apply sq_nonneg
  intro h
  use ‚àöz
  exact sq_sqrt h

end

section
variable {Œ± Œ≤ : Type*} [Inhabited Œ±]

#check (default : Œ±)

variable (P : Œ± ‚Üí Prop) (h : ‚àÉ x, P x)

#check Classical.choose h

example : P (Classical.choose h) :=
  Classical.choose_spec h

noncomputable section

open Classical

def inverse (f : Œ± ‚Üí Œ≤) : Œ≤ ‚Üí Œ± := fun y : Œ≤ ‚Ü¶
  if h : ‚àÉ x, f x = y then Classical.choose h else default

theorem inverse_spec {f : Œ± ‚Üí Œ≤} (y : Œ≤) (h : ‚àÉ x, f x = y) : f (inverse f y) = y := by
  rw [inverse, dif_pos h]
  exact Classical.choose_spec h

variable (f : Œ± ‚Üí Œ≤)

open Function

#print LeftInverse
#print RightInverse

-- TODO: could be shorter, oneline?
example : Injective f ‚Üî LeftInverse (inverse f) f := by
  -- ‚àÄ x1 x2, f x1 = f x2 ‚Üí x1 = x2  ‚Üî  ‚àÄ x, (inverse f) (f x) = x
  constructor
  ¬∑ intro finj x
    have hinv : ‚àÉz, f z = f x := by use x
    rw [inverse, dif_pos hinv]
    exact finj (Classical.choose_spec hinv)
  intro hli x1 x2 he
  have hli2 : (inverse f) (f x2) = x2 := hli x2
  exact (hli x1).symm.trans (he ‚ñ∏ hli2)


-- Pow, short proof! üí•
--
-- Using _'s to identify types, then unifying with things that can be constructed
-- easily from context
--
-- aesop? and simp? get nowhere
example : Injective f ‚Üî LeftInverse (inverse f) f :=
  -- ‚àÄ x1 x2, f x1 = f x2 ‚Üí x1 = x2  ‚Üî  ‚àÄ x, (inverse f) (f x) = x
  ‚ü® fun finj => fun x => finj (inverse_spec (f x) (by use x)),
    fun linv => fun x1 x2 fx1x2 => (linv x1).symm.trans (fx1x2.symm ‚ñ∏ (linv x2))
    -- more fully spelling out the motive in the substitution:
    -- fun linv => fun x1 x2 fx1x2 => Eq.trans (linv x1).symm (Eq.subst (motive := fun z => (inverse f) z = x2) fx1x2.symm (linv x2))
  ‚ü©


-- Pow, short proof! üí•
example : Surjective f ‚Üî RightInverse (inverse f) f :=
  -- ‚àÄ y, ‚àÉ x, f x = y  ‚Üî  ‚àÄ y, f ((inverse f) y) = y
  ‚ü® fun fsurj => fun y => inverse_spec y (fsurj y),
    fun rinv  => fun y => ‚ü®(inverse f) y, rinv y‚ü©‚ü©

end

section
variable {Œ± : Type*}
open Function

theorem Cantor : ‚àÄ f : Œ± ‚Üí Set Œ±, ¬¨Surjective f := by
  intro f surjf
  let S := { i | i ‚àâ f i }
  rcases surjf S with ‚ü®j, h‚ü©
  have h‚ÇÅ : j ‚àâ f j := by
    intro h'
    have : j ‚àâ f j := by rwa [h] at h'
    contradiction
  have h‚ÇÇ : j ‚àà S
  sorry
  have h‚ÇÉ : j ‚àâ S
  sorry
  contradiction

-- COMMENTS: TODO: improve this
end
